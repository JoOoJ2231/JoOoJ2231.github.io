# Numpy 란?

#### 넘파이란 파이썬 패키지의 일종으로 다차원행렬 구조인 ndarray을 통해 벡터와 행렬계산을 빠르고 손쉽게 할 수 있게 해준다. (본래 수치해석용으로 개발되었다고 한다. 그러니까 엄청 똑똑한 사람이 (Travis Oliphant) 수치해석하다가 답답해서 코드로 수치해석에 필요한 함수들과 클래스를 정의해서 모아둔 것이 널리 배포되어 여기까지 오게 된것이다..)

** 패키지란?: 도트(.)를 사용하여 파이썬 모듈을 계층적(디렉터리 구조)으로 관리할 수 있게 해준다. 예를 들어 모듈 이름이 A.B인 경우에 A는 패키지 이름이 되고 B는 A 패키지의 B모듈이 된다. ex. plt.plot()

## 1. 벡터화 연산 가능
#### 넘파이의 가장 강력한 특징이 선형대수 계산을 빠르고 쉽게 해준다는 것인데 구체적으로 어떻게 그럴까? 아래 예시를 보자


```python
import numpy as np
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(type(a))
a


```

    <class 'numpy.ndarray'>





    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



얼핏보기에 리스트를 만든것처럼 보이나, 이는 ndarray 라는, 넘파이에서 지원하는 새로운 데이터 타입이다.   
왜 굳이 리스트를 두고 이런걸 만들었나? 아래 예시를 한번보자


```python
a**2
```




    array([ 0,  1,  4,  9, 16, 25, 36, 49, 64, 81])




```python
b=list[1,2,3,4,5,6,7,8,9]
b**2
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    /var/folders/q8/p_lbgb2j2b37x4b4dp3t5m0c0000gn/T/ipykernel_2032/2411625378.py in <module>
    ----> 1 b=list[1,2,3,4,5,6,7,8,9]
          2 b**2


    TypeError: 'type' object is not subscriptable


ndarray는 직관적으로 데이터를 제곱했을때, 내부 요소들 또한 자동으로 같은 연산이 처리된다. 각 원소에 대한 연산을 한번에 처리하는 것을 벡터화 연산이라고 한다. list는 같은 방식으로 하면 오류가 나게 된다.

하지만 list 내 원소들은 다른 데이터 타입을 가질 수 있는 반면, ndarray는 같은 데이터타입이어야 한다는 단점이 있다.

## 2. 다차원 행렬 생성의 용이

선형대수가 행렬을 다루는 학문이므로 선형대수 계산을 빠르게 하려면 행렬처리도 손쉬워야한다. 그래서 넘파이는 다양한 행렬구조를 직관적으로 지원한다.


```python
a = np.array([0, 1, 2])    
a
```




    array([0, 1, 2])




```python
b = np.array([[0, 1, 2], [3, 4, 5]])    # 2 x 3 array
b
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
c = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])   # 2 x 2 x 2 array
c
```




    array([[[1, 2],
            [3, 4]],
    
           [[5, 6],
            [7, 8]]])



위 예시 처럼 리스트형태로 행을 만들어 array함수에 넣어주면, 그에 맞는 다차원행렬이 쉽게 생성됨을 알 수 있다.

## 3. 행렬의 슬라이싱과 인덱싱

파이썬에서의 슬라이싱 및 인덱싱 기능을 넘파이에서 ndarray 데이터 타입에도 그대로 사용할 수 있다. 따라서 행렬 연산에 있어 아주 강력한 기능으로 평가받고 있다.

행렬 슬라이싱 예시


```python
a = np.array([[0,1,2],[3,4,5]])
a
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
a[1,2]
```




    5




```python
a[:,0]
```




    array([0, 3])




```python
a[0:,2]
```




    array([2, 5])



행렬 인덱싱에서는 대괄호(Bracket, [])안의 인덱스 정보로 숫자나 슬라이스가 아닌 ndarray 행렬을 받을 수 있다. 즉, 추출하려고 슬라이싱 하는 행위에 행렬을 넣을수도 있다는 것이다.
그 행렬의 종류에 따라서 불리안(Boolean) 행렬 방식과 정수 행렬 방식 두가지가 있다.

아래 예시를 한번보자




```python
indexing = np.array([[True, False, True], [False, True, True]])
a[indexing]
```




    array([0, 2, 4, 5])



a와 똑같은 행렬 구조를 boolean 타입으로 이루어진 ndarray를 만들면, 위와 같이 True인 부분만 추출되어짐을 볼 수 있다!!


```python
a[a%2 ==0]
```




    array([0, 2, 4])



또한 행렬 원소 중에서 위와 같이 간단한 조건을 사용해서 원하는 조건의 원소를 추출할 수도 있다


```python
[a%2 ==0]
```




    [array([[ True, False,  True],
            [False,  True, False]])]



조건문만 사용할 경우, 이렇게 원소별 조건이 맞는지 틀린지 계산해서 boolean타입으로 반환해준다. 


```python
a[(a%2 ==0) & (a>2) ]
```




    array([4])




```python

```
